#!/usr/bin/env python

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# For factory and autoupdate, after shellball self-extracts, this script is
# called to update BIOS and EC firmware as per how many files are extracted.

import flashrom_util
import os
import sys
import types

# customizable parameters
# ----------------------------------------------------------------------------
# If you want to customize any of these parameters, make a python script
# and name it as the constant string in DEFAULT_CUSTOM_SCRIPT_FILENAME.

# The script to be loaded for customization. You cannot change this value.
DEFAULT_CUSTOM_SCRIPT_FILENAME = "install_firmware_custom.py"

# flasrom(8) tool path, can be changed to use system default flashrom
DEFAULT_FLASHROM_TOOLPATH = './flashrom'

# Target Map, can be customized to allow remapping BBS registers / flash map
DEFAULT_FLASHROM_TARGET_MAP = None

# Prefix of every command for flashrom command execution. You can adjust
# environment variables like PATH or other things here.
DEFAULT_FLASHROM_CMDPREFIX = 'PATH=".:$PATH";export PATH;'

# Default folder for flashrom command to create temporary files. None
# means /tmp or $TMP.
DEFAULT_FLASHROM_TEMPROOT = None

# ChromeOS Flash ROM Layout description. Customize this if you want override
# flashrom_util.py:flashrom_util.default_chromeos_layout_desc
DEFAULT_CHROMEOS_LAYOUT_DESC = None

# Update configuration list, can be changed to override the ro/rw partitions
# that needs to be changed in auto update.
# The part names should match the layout by DEFAULT_CHROMEOS_LAYOUT_DESC.
#  name:     a display name for target
#  filename: the image carried in shellball package for update
#  ro_parts: a list (separated by ',') of readonly parts. if any RO part
#            is different, enter factory setup mode.
#  rw_set: a set of parts list (by list of strings separated by ',') of
#            read-write parts.
#  reboot_cmd: The command to invoke if system requires a reboot
#  skip_verify: comma-separated list of string tuples (separated by ':')
#            PARTNAME:OFFSET:SIZE which is used when flashrom will be
#            automatically changed during write (eg, timestamp, checksum)
#  select_cmd: when rw_set is a multiple set, this list carries commands to be
#            invoked if we want to select a set or RW for next boot
#  get_last_index: when rw_set is a multiple set, this function return
#            a zero-based index of "which RW set was used last time".
#  background: this target is safe for background update.
DEFAULT_TARGETS = {
    "bios": {
        "name": "BIOS",
        "filename": "bios.bin",
        "ro_parts": "FV_BSTUB,FV_GBB,FVDEV",
        "rw_set": ["VBOOTA,FVMAIN", "VBOOTB,FVMAINB"],
        "skip_verify": [],
        "reboot_cmd": "py:chromeos_need_reboot()",
        # multiple set configuration
        "select_cmd": ["py:chromeos_set_next_boot(0)",
                       "py:chromeos_set_next_boot(1)"],
        "get_last_index": "py:chromeos_get_last_boot_index()",
        "background": True,
    },
    "ec": {
        "name": "Embedded Controller",
        "filename": "ec.bin",
        "ro_parts": "EC_RO",
        "rw_set": ["EC_RW"],
        "skip_verify": "EC_RO:0x48:4",
        "reboot_cmd": "py:chromeos_need_reboot()",
        "select_cmd": [""],
        "get_last_index": "",
        "background": False,
    },
}

# Chrome OS ACPI folder. Usually you will only change this for debug purpose.
CHROMEOS_ACPI_ROOT = '/sys/devices/platform/chromeos_acpi/'

# Chrome OS control tag file to request firmware update after reboot
CHROMEOS_NEED_REBOOT_TAG = '/mnt/stateful_partition/.need_firmware_update'

# Chrome OS factory mode control tag files (see chromeos_startup)
CHROMEOS_FACTORY_TEST_TAG = '/root/.factory_test'
CHROMEOS_FACTORY_INSTALLER_TAG = '/root/.factory_installer'

# Set this to True for more messages
is_verbose = False

# Set this to True to enable background update process
is_background = False

# Set this to True to enable factory test/installer mode
is_factory = False

# ----------------------------------------------------------------------------
# Firmware Update Procedure
#
# TODO(hungte) We can check firmware version number with the version in TPM
#              later. If it's older than TPM then we can skip update process
#              because we know it will eventually fail.
# ----------------------------------------------------------------------------
# We support both factory setup and auto-update here.
# 1. Read current flashrom.
# 2. If RO part is different (factory first-time setup), rewrite whole image:
#    2a. If rewrite failed, abort.
#    2b. If rewrite succeeded, exit as normal.
# 3. If we are running in 'factory test' or 'factory installer' mode,
#    update all different RW parts at the same time.
#    3a. If rewrite failed, abort.
#    3b. If rewrite succeeded, exit as normal.
# 4. (partial-update) Compare RW parts, and rewrite only those different.
#    NOTE: for ChromeOS main firmware (A/B design), see "Chrome OS Main Firmware
#    Update Procedure" below, otherwise:
#    4a. If rewrite failed, abort.
#    4b. If rewrite succeeded, exit as normal or reboot if required.
# ----------------------------------------------------------------------------
# Chrome OS Main Firmware Update Procedure:
#   The following procedure use these terms to refer firmware images:
#   A = firmware A in current flash ROM (VBOOTA+FVMAIN)
#   B = firmware B in current flash ROM (VBOOTB+FVMAINB)
#   T = "target", image carried in update pack (shellball, part A == part B)
# 1. If T == B == A, that means no need to update.
#    Do nothing and exit.
# 2. Get last boot firmware index.
# 3. If last boot = B...
#    Do copy B to A.
#    3a. If T == B, that means a successful update.
#        Do nothing and exit.
#    3b. If T != B, that means A went bad.
#        Skip to 5.
# 4. Now last boot = A.
#    If T == B, that means trial boot from B failed;
#        Do copy A to B and exit.
# 5. Now T != B...
#    Do copy T to B.
#    5a. If T != A, this is a fresh update we need to try.
#        Set firmware_try_b and reboot.
#    5b. If T == A, this means B went bad.
#        Simply do nothing (no need to reboot).
# ----------------------------------------------------------------------------

# utility functions


def error_die(msg):
    """ Reports error message and exit(1) """
    print "ERROR:", msg
    sys.exit(1)


def csv_to_list(csv, delimiter=','):
    """
    Converts a comma-separated-value (or list) to a list

    To use symbols other that comma, customize with delimiter.
    """
    if isinstance(csv, types.StringTypes):
        return [i.strip() for i in csv.split(delimiter)]
    return csv


def execute_script_command(cmd):
    """
    Executes a python script or shell command.

    If cmd starts with "py:" then execute as python script,
    otherwise invoke as shell command.
    """
    PY_PREFIX = "py:"
    if cmd.startswith(PY_PREFIX):
        return eval(cmd[len(PY_PREFIX):])
    if os.system(cmd) == 0:
        return True
    return False


# ----------------------------------------------------------------------------
# Advanced firmware updater


class FirmwareUpdater(object):
    """
    The update utility which supports log based style read/write to flashrom.

    To use it, first initialize, update section data, and finally commit.
    Example:
        updater = FirmwareUpdater()
        updater.initialize('bios')
        updater.update_section(list_A, list_B, image);  # copy A in image to B
        updater.commit()

    Attributes
        flashrom:       instance of flashrom_util
        current_image:  cached image data of current flashrom
        layout:         the Chrome OS firmware layout for flashrom to use
        whole_flash_layout: a simple layout to access whole flash memory
        skip_verify:    a description of what data must be skipped when
                        doing compare / verification
        update_history: a list of every change we should apply when committing.
                        each item is (update_list, image_data).
    """

    def __init__(self):
        """ Initializes internal variables and states """
        self.flashrom = flashrom_util.flashrom_util(
                tool_path=DEFAULT_FLASHROM_TOOLPATH,
                cmd_prefix=DEFAULT_FLASHROM_CMDPREFIX,
                tmp_root=DEFAULT_FLASHROM_TEMPROOT,
                target_map=DEFAULT_FLASHROM_TARGET_MAP,
                verbose=is_verbose)
        self.current_image = None
        self.layout = None
        self.whole_flash_layout = None
        self.skip_verify = None
        self.update_history = []

    def initialize(self, target, skip_verify):
        """ Starts flashrom initialization with given target """
        flashrom = self.flashrom
        if not flashrom.select_target(target):
            error_die("Cannot Select Target. Abort.")
        print " - reading current content"
        self.current_image = flashrom.read_whole()
        if not self.current_image:
            error_die("Cannot read flashrom image. Abort.")
        flashrom_size = len(self.current_image)

        # decide layout
        if DEFAULT_CHROMEOS_LAYOUT_DESC:
            if target not in DEFAULT_CHROMEOS_LAYOUT_DESC:
                error_die("Invalid target in customized layout description.")
            desc = DEFAULT_CHROMEOS_LAYOUT_DESC[target]
            layout = flashrom.detect_laout(desc, flashrom_size)
        else:
            layout = flashrom.detect_chromeos_layout(target, flashrom_size)
        self.layout = layout
        self.whole_flash_layout = flashrom.detect_layout('all', flashrom_size)
        self.skip_verify = skip_verify
        self.update_history = []  # reset list

    def get_current_image(self):
        """ Returns current flashrom image (physically, not updated) """
        return self.current_image

    def get_latest_update_image(self):
        """ Returns the latest updated result image (not written yet) """
        if not self.update_history:
            return self.get_current_image()
        # the [1] refers to the latter element of (update_list, image_data)
        return self.update_history[-1][1]

    def need_commit(self):
        """ Returns if we have uncommited updates """
        if self.update_history:
            return True
        return False

    def update_sections(self, from_list, to_list, from_image=None):
        """
        Changes sections (in from_list) of data from from_image to the sections
        (in to_list) in latest updated image.

        from_list and to_list can be real list or comma-separated-value.
        """
        # simplify arguments and local variables
        if not from_image:
            from_image = self.get_latest_update_image()
        to_image = self.get_latest_update_image()
        from_list = csv_to_list(from_list)
        to_list = csv_to_list(to_list)
        update_list = []
        update_image = to_image
        flashrom = self.flashrom
        layout = self.layout

        for f, t in zip(from_list, to_list):
            if self.verify_sections(f, t, from_image, to_image):
                continue
            from_data = flashrom.get_section(from_image, layout, f)
            to_data = flashrom.get_section(to_image, layout, t)
            assert len(from_data) == len(to_data)
            update_image = flashrom.put_section(update_image, layout, t,
                                                from_data)
            assert update_image != to_image
            update_list.append(t)

        # add to history if anything has been changed.
        if update_list:
            self.update_history.append((update_list, update_image))
            assert update_image != to_image

    def verify_sections(self, from_list, to_list, from_image, to_image):
        """
        Compares if sections in from_list and to_list are the same, skipping
        by self.skip_verify description.

        If from_list and to_list are both empty list ([]), compare whole image
        """
        # simplify arguments and local variables
        from_list = csv_to_list(from_list)
        to_list = csv_to_list(to_list)
        flashrom = self.flashrom
        layout = self.layout

        # decode skip_verify with layout, and then modify images
        for verify_tuple in csv_to_list(self.skip_verify):
            (name, offset, size) = verify_tuple.split(':')
            name = name.strip()
            offset = int(offset.strip(), 0)
            size = int(size.strip(), 0)
            if name not in layout:
                error_die("Unknown section name in skip_verify: %s" % name)
            if is_verbose:
                print " ** skipping range: %s +%d [%d]" % (name, offset, size)
            # XXX we use the layout's internal structure here...
            offset = layout[name][0] + offset
            from_image = from_image[:offset] + (chr(0)*size) + \
                         from_image[(offset + size):]
            to_image = to_image[:offset] + (chr(0) * size) + \
                       to_image[(offset + size):]

        # compare sections in image
        if not (from_list or to_list):
            return from_image == to_image
        for (f, t) in zip(from_list, to_list):
            data_f = flashrom.get_section(from_image, layout, f)
            data_t = flashrom.get_section(to_image, layout, t)
            if data_f != data_t:
                return False
        return True

    def verify_whole_image(self, image1, image2):
        """ Compares if image1 and image2 are the same, except the
        skip_verify region.
        """
        return self.verify_sections([], [], image1, image2)

    def perform_write_flash(self, update_list, layout, update_image):
        """ (INTERNAL) Performs a real write to flashrom. """
        flashrom = self.flashrom
        print " - updating firmware sections:", ','.join(update_list)
        if not flashrom.write_partial(update_image, layout, update_list):
            error_die("Cannot re-write firmware. Abort.")
        print " - verifying updated firmware data"
        verify_image = flashrom.read_whole()
        self.current_image = verify_image
        if not self.verify_whole_image(verify_image, update_image):
            error_die("Tool return success but actual data is incorrect.")

    def commit(self):
        """ Commits all updated data into real flashrom """
        for update_list, update_image in self.update_history:
            self.perform_write_flash(update_list, self.layout, update_image)
        # all commited, clear log history
        self.update_history = []

    def commit_whole_flashrom_image(self, image):
        """ Updates (and commits directly) whole new flashrom image """
        whole_layout = self.whole_flash_layout
        assert len(whole_layout) == 1
        self.perform_write_flash(whole_layout.keys(), whole_layout, image)


# ----------------------------------------------------------------------------
# Chrome-OS specific utility functions


def chromeos_get_last_boot_index():
    """ Utility to get last boot BIOS firmware index"""
    # See "Google Chrome OS Firmware - High Level Specification" section
    # "BINF (Chrome OS boot information)" for more detail.
    binf_mainfw = os.path.join(CHROMEOS_ACPI_ROOT, "BINF.1")
    if not os.path.exists(binf_mainfw):
        return -1
    value = open(binf_mainfw).read().strip()
    # ACPI value: 0=recovery, 1=firmwareA, 2=firmwareB
    # get_index return values requires 0=A, 1=B
    # so we remap the return value to: recovery=firmwareA=0, firmwareA=1
    # recovery is mapped to zero(A) because booting from B has special meaning
    # (check the behavior of firmware_try_b in ChromeOS firmware)
    acpi_value_to_index_map = {
        '0': 0,
        '1': 0,
        '2': 1,
    }
    # all other unknown cases, return as error.
    if value not in acpi_value_to_index_map:
        return -1
    if is_verbose:
        v = acpi_value_to_index_map[value]
        print "  * last_boot: %s=>%d (%c)" % (
                value, v, chr(ord('A') + v))
    return acpi_value_to_index_map[value]


def chromeos_detect_factory_mode():
    """ Detects if we are running under ChromeOS factory testing mode """
    if os.path.exists(CHROMEOS_FACTORY_TEST_TAG) or \
       os.path.exists(CHROMEOS_FACTORY_INSTALLER_TAG):
           return True
    return False


def chromeos_need_reboot():
    """
    Utility to schedule a system reboot.

    In current Chrome OS Auto Update design, the actual behavior is to
    requst firmware update script being executed again after reboot.
    """
    open(CHROMEOS_NEED_REBOOT_TAG, "w").close()
    return True


def chromeos_set_next_boot(index):
    """
    Utility to set next firmware boot to given index.

    index: 0=A, 1=B.
    We use the "try_firmware_b" to configure it.
    """
    try_firmware_b_values = [0, 1]
    cmd = '/usr/sbin/reboot_mode --try_firmware_b=%d' % (
            try_firmware_b_values[index])
    return execute_script_command(cmd)


def chromeos_firmware_AB_update(
        updater,
        last_boot_index, index_A, index_B,
        sections_A, sections_B,
        target_image):
    """
    Performs Chrome OS "AB Main Firmware" Update Rules

    updater: instance of FirmwareUpdater
    last_boot_index: index of last boot (A=0, B=1)
    index_A, index_B: index of firmware A/B (should be 0/1 currently)
    sections_A, sections_B: complete description of (all) sections in fw A/B
    target_image: flashrom image data in update pack (target)

    Returns a list of (need_reboot, next_boot_index)
    """

    base = updater.get_current_image()
    target = target_image
    T_equals_A = updater.verify_sections(sections_A, sections_A, base, target)
    T_equals_B = updater.verify_sections(sections_B, sections_B, base, target)
    next_boot_index = index_A
    need_reboot = False

    assert not (T_equals_A and T_equals_B)  # T==A==B should be already handled.
    assert (last_boot_index == index_A) or (last_boot_index == index_B)
    # A, B should be the same for target image.
    assert updater.verify_sections(sections_A, sections_B, target, target)

    # Basically we allow remapping index of A and B to other values.
    # However in order to prevent typo, we force (A, B) to be (0, 1) currently -
    # until some day that we need to change it.
    assert index_A == 0
    assert index_B == 1

    if last_boot_index == index_B:
        # do copy B to A
        updater.update_sections(sections_B, sections_A)
        if T_equals_B:
            # means a successful update
            if is_verbose:
                print " * action: copy B to A (after successful update)"
            return (need_reboot, next_boot_index)
        else:
            # means A went bad
            if is_verbose:
                print " * action: copy B to A (A went bad)"
            # continue and pretend we've boot from A
            last_boot_index = index_A
            T_equals_A = T_equals_B

    assert last_boot_index == index_A
    if T_equals_B:
        # trial boot from B failed (need recover)
        if is_verbose:
            print " * action: copy A to B (after boot failure)"
        # do copy A to B
        updater.update_sections(sections_A, sections_B)
        return (need_reboot, next_boot_index)

    assert (not T_equals_B)
    # either a flash update, or B went bad
    # do copy T to B
    updater.update_sections(sections_B, sections_B, target_image)
    if not T_equals_A:
        next_boot_index = index_B
        need_reboot = True
        if is_verbose:
            print " * action: copy T to B (flash update, try_b then reboot)"
    else:
        if is_verbose:
            print " * action: copy T to B (B went bad)"
    return (need_reboot, next_boot_index)


# ---------------------------------------------------------------------------
# MAIN PROCEDURE START HERE


def update_target_firmware(target, data):
    """ the main update procedure """
    # pre-check configuration
    assert 'filename' in data
    assert 'name' in data
    assert 'ro_parts' in data
    assert 'rw_set' in data
    assert 'reboot_cmd' in data
    assert 'skip_verify' in data
    assert 'select_cmd' in data
    assert 'get_last_index' in data
    assert 'background' in data
    assert len(data['rw_set']) == len(data['select_cmd'])

    if not os.path.exists(data['filename']):
        print "Updating %s (Skipped - no image in package)..." % data['name']
        return

    new_image = open(data['filename'], 'rb').read()
    if not new_image:
        error_die("Invalid image file. Abort.")

    # main process
    print "* Updating %s..." % data['name']
    updater = FirmwareUpdater()
    updater.initialize(target, data['skip_verify'])

    # It is possible to check write protection status via $ACPI_ROOT/BINF.3
    # (Boot GPIO States) or use factory mode tags to decide if we can update
    # RO. However a different RO (with write protected) usually means we're
    # running on a different (wrong) configuration.  So the logic here is, if
    # RO is different, rewrite entire image or fail.

    print " - checking RO data"
    ro_list = data['ro_parts']
    base_image = updater.get_latest_update_image()
    if not updater.verify_sections(ro_list, ro_list, new_image, base_image):
        # factory (first-time) setup here.
        print " - start factory (first-time) setup"
        updater.commit_whole_flashrom_image(new_image)
        print " - success and complete."
        return

    # factory mode, with RO ok. try to update all RW at the same time.
    if is_factory:
        print " - start factory (RW-only) update"
        # combine all rw sets
        rw_list = ','.join(data['rw_set'])
        updater.update_sections(rw_list, rw_list, new_image)
        if not updater.need_commit():
            print " - no need to update."
        else:
            updater.commit()
            print " - success and complete."
        return

    # auto update here.
    print " - start auto-partial-update"
    rw_set = data['rw_set']
    last_boot_index = 0

    print " - checking RW data"
    all_rw_set = ','.join(rw_set)
    base_image = updater.get_latest_update_image()
    if updater.verify_sections(all_rw_set, all_rw_set, new_image, base_image):
        # T==A==B, everything is updated
        print " - already updated to latest version."
        return

    # determine what task should we do
    if len(rw_set) > 1:
        # this is a multiple-set firmware.
        assert len(rw_set) == 2, "INTERNAL ERR: Unknown multiple set"
        assert data['get_last_index']
        print " - checking last-used firmware"
        last_boot_index = execute_script_command(data['get_last_index'])
        if last_boot_index < 0 or last_boot_index >= len(rw_set):
            error_die("Cannot find proper index. Abort.")
        # perform a Chrome OS firmware A/B update
        need_reboot, next_boot_index = chromeos_firmware_AB_update(
                updater, last_boot_index, 0, 1, rw_set[0], rw_set[1], new_image)
    else:
        assert len(rw_set) == 1, "INTERNAL ERR: must provide one update"
        # perform simple update
        need_reboot = 0
        next_boot_index = last_boot_index
        update_list = rw_set[0]
        updater.update_sections(update_list, update_list, new_image)

    if updater.need_commit():
        if is_background and (not data['background']):
            print " - running in background update mode, postpone to next boot."
            need_reboot = True
        else:
            updater.commit()

    # NOTE you may check here again if the behavior of firmware_try_b changed.
    if next_boot_index != last_boot_index:
        print " - selecting firmware #%d for next boot" % next_boot_index
        cmd = data['select_cmd'][next_boot_index]
        if not execute_script_command(cmd):
            error_die("Cannot set next boot firmware to #%d" % next_boot_index)
    if need_reboot:
        print " - need to reboot..."
        cmd = data['reboot_cmd']
        if not execute_script_command(cmd):
            error_die("Cannot set reboot flag.")
    print " - success and complete."


def usage_help():
    """ Print script usage help """
    print '''
%s [options]

options:
    --background-update  Skip update that may freeze keyboard / reboot (eg, EC)
    --verbose            Print verbose messages
    --help               This help message''' % sys.argv[0]
    return


def main():
    """ main stub """
    # parse command line
    global is_verbose, is_background, is_factory
    for arg in sys.argv[1:]:
        if arg == '-h' or arg == '--help':
            usage_help()
            return
        elif arg == '--verbose':
            is_verbose = True
        elif arg == '--factory':
            is_factory = True
            if is_verbose:
                print ' * Enable factory mode'
        elif arg == '--background-update':
            is_background = True
            if is_verbose:
                print ' * Enable background update mode'
        else:
            print "Warning: unknown parameter:", arg

    # detect and adjust factory/background modes
    if (not is_factory) and chromeos_detect_factory_mode():
        is_factory = True
    if is_factory:
        is_background = False

    # if there is a custom script, load it now.
    custom_script = DEFAULT_CUSTOM_SCRIPT_FILENAME
    if os.path.exists(custom_script):
        # to prevent writing 'global var' in the custom script,
        # we pass globals() as both locals and globals to execfile
        execfile(custom_script, globals())

    # update all firmware targets
    for (target, data) in DEFAULT_TARGETS.items():
        update_target_firmware(target, data)
    print "* Firmware Update Complete."


if __name__ == '__main__':
    main()
