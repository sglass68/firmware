#!/usr/bin/env python

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# For factory and autoupdate, after shellball self-extracts, this script is
# called to update BIOS and EC firmware as per how many files are extracted.

import flashrom_util
import os
import sys

# customizable parameters
# ----------------------------------------------------------------------------
# If you want to customize any of these parameters, make a python script
# and name it as the constant string in DEFAULT_CUSTOM_SCRIPT_FILENAME.

# The script to be loaded for customization. You cannot change this value.
DEFAULT_CUSTOM_SCRIPT_FILENAME = "install_firmware_custom.py"

# flasrom(8) tool path, can be changed to use system default flashrom
DEFAULT_FLASHROM_TOOLPATH = './flashrom'

# Target Map, can be customized to allow remapping BBS registers / flash map
DEFAULT_FLASHROM_TARGET_MAP = None

# Prefix of every command for flashrom command execution. You can adjust
# environment variables like PATH or other things here.
DEFAULT_FLASHROM_CMDPREFIX = 'PATH=".:$PATH";export PATH;'

# ChromeOS Flash ROM Layout description. Customize this to override
# flashrom_util.py:flashrom_util.default_chromeos_layout_desc
DEFAULT_CHROMEOS_LAYOUT_DESC = None

# Update configuration list, can be changed to override the ro/rw partitions
# that needs to be changed in auto update.
# The part names should match the layout by DEFAULT_CHROMEOS_LAYOUT_DESC.
DEFAULT_TARGETS = {
    "bios": {
        "name": "BIOS",
        "filename": "bios.bin",
        "ro_parts": "FV_BSTUB,FV_GBB,FVDEV",
        "rw_set": ["VBOOTA,FVMAIN", "VBOOTB,FVMAINB"],
        "skip_verify": "",
        "select_cmd": ["/usr/sbin/reboot_mode --try_firmware_b=0",
                       "/usr/sbin/reboot_mode --try_firmware_b=1"],
        "get_last_index": "py:get_last_boot_bios_index()",
    },
    "ec": {
        "name": "Embedded Controller",
        "filename": "ec.bin",
        "ro_parts": "EC_RO",
        "rw_set": ["EC_RW"],
        "skip_verify": "EC_RO:0x48:4",
        "select_cmd": [""],
        "get_last_index": "",
    },
}

# Chrome OS ACPI folder. Usually you will only change this for debug purpose.
CHROMEOS_ACPI_ROOT = '/sys/devices/platform/chromeos_acpi/'

# Set this to True for more messages
is_verbose = False

# ----------------------------------------------------------------------------
# Firmware Update Procedure
# ----------------------------------------------------------------------------
# We support both factory setup and auto-update here.
# 1. Read current flashrom.
# 2. If RO part is different (factory setup), rewrite whole image; otherwise 3.
#  2a. If rewrite failed, abort.
#  2b. If rewrite succeeded, exit as normal.
# 3. (auto-update) Get last boot firmware index, say A in the following sample.
# 4. Compare the other (non-booted) firmware (B in this sample) RW parts.
#    If any part is different, add into update list.
# 5. Rewrite every parts in update list. If rewrite failed, abort.
# 6. Set next boot indicator to the updated firmware (B in this sample).


# utility functions
def error_die(msg):
    """ Reports error message and exit(1) """
    print "ERROR:", msg
    sys.exit(1)


def execute_script_command(cmd):
    """
    Executes a python script or shell command.

    If cmd starts with "py:" then execute as python script,
    otherwise invoke as shell command.
    """
    PY_PREFIX = "py:"
    if cmd.startswith(PY_PREFIX):
        return eval(cmd[len(PY_PREFIX):])
    if os.system(cmd) == 0:
        return True
    return False


def get_last_boot_bios_index():
    """ Utility to get last boot BIOS firmware index"""
    # See "Google Chrome OS Firmware - High Level Specification" section
    # "BINF (Chrome OS boot information)" for more detail.
    binf_mainfw = os.path.join(CHROMEOS_ACPI_ROOT, "BINF.1")
    if not os.path.exists(binf_mainfw):
        return -1
    value = open(binf_mainfw).read().strip()
    # ACPI value: 0=recovery, 1=firmwareA, 2=firmwareB
    # get_index return values requires 0=A, 1=B
    # so we remap the return value to: recovery=firmwareB=1, firmwareA=0
    acpi_value_to_index_map = {
        '0': 1,
        '1': 0,
        '2': 1,
    }
    # all other unknown cases, return as error.
    if value not in acpi_value_to_index_map:
        return -1
    return acpi_value_to_index_map[value]


def apply_skip_verify(skip_pattern, layout, flashrom, original, expected):
    """
    Utility to make a modified (based by original) data with the portion
    defined in skip_pattern changed to that part in expected.

    Return value is original[expected]original, where expected value replaced
    the corresponding region in original.

    syntax of skip_pattern:
        NAME:OFFSET:SIZE,NAME:OFFSET:SIZE,...

    NAME is the section name defined in layout,
    OFFSET is a numeric number as offset from section start,
    SIZE is a numeric number for the region size to be skipped.
    """
    if not skip_pattern:
        return original
    for verify_tuple in skip_pattern.split(','):
        (name, offset, size) = verify_tuple.split(':')
        if name not in layout:
            continue
        offset = int(offset, 0)
        size = int(size, 0)
        if is_verbose:
            print " ** skipping range: %s +%d [%d]" % (name, offset, size)
        # assert voffset + vsize < layout[vname][1] - layout[vname][0]
        v_original = flashrom.get_section(original, layout, name)
        v_expected = flashrom.get_section(expected, layout, name)
        # build new pattern
        v_new = v_original[0:offset] + v_expected[offset:(offset+size)] \
                + v_original[(offset+size):]
        assert len(v_new) == len(v_expected)
        original = flashrom.put_section(original, layout, name, v_new)
    return original


# ---------------------------------------------------------------------------
# MAIN PROCEDURE START HERE


def update_taget_firmware(target, data, flashrom):
    """ the main update procedure """
    # pre-check configuration
    assert 'filename' in data
    assert 'name' in data
    assert 'ro_parts' in data
    assert 'rw_set' in data
    assert 'skip_verify' in data
    assert 'select_cmd' in data
    assert 'get_last_index' in data
    assert len(data['rw_set']) == len(data['select_cmd'])

    if not os.path.exists(data['filename']):
        print "Updating %s (Skipped - no image in package)..." % data['name']
        return

    new_image = open(data['filename'], 'rb').read()
    if not new_image:
        error_die("Invalid image file. Abort.")

    # main process
    print "Updating %s..." % data['name']
    if not flashrom.select_target(target):
        error_die("Cannot Select Target. Abort.")

    print " - reading current content"
    current_image = flashrom.read_whole()
    if not current_image:
        error_die("Cannot read flashrom image. Abort.")

    flashrom_size = len(current_image)
    if DEFAULT_CHROMEOS_LAYOUT_DESC:
        if target not in DEFAULT_CHROMEOS_LAYOUT_DESC:
            error_die("Invalid target in customized layout description.")
        desc = DEFAULT_CHROMEOS_LAYOUT_DESC[target]
        layout = flashrom.detect_laout(desc, flashrom_size)
    else:
        layout = flashrom.detect_chromeos_layout(target, flashrom_size)
    whole_flash = flashrom.detect_layout('all', flashrom_size)
    if (not layout) or (not whole_flash):
        error_die("Cannot detect layout. Abort.")

    # TODO(hungte) in the future we can also check $ACPI_ROOT/BINF.3 (Boot GPIO
    # States, which is currently not available) for write-protection info.
    print " - checking RO data"
    is_factory_setup = False
    ro_list = data['ro_parts'].split(',')
    verify_image = apply_skip_verify(data['skip_verify'], layout, flashrom,
                                     new_image, current_image)
    for ro in ro_list:
        ro = ro.strip()
        current_data = flashrom.get_section(current_image, layout, ro)
        expected_data = flashrom.get_section(verify_image, layout, ro)
        if current_data != expected_data:
            is_factory_setup = True
            break

    # factory setup here.
    if is_factory_setup:
        print " - start factory setup"
        if not flashrom.write_partial(new_image, whole_flash, ('all', )):
            error_die("Cannot re-write Flash ROM. Abort.")
        print " - verifying data"
        verify_data = flashrom.read_whole()
        verify_data = apply_skip_verify(data['skip_verify'], layout, flashrom,
                                        verify_data, new_image)
        if verify_data != new_image:
            error_die("Tool return success but actual data is incorrect.")
        print " - success and complete."
        return

    # auto update here.
    print " - start auto-partial-update"
    rw_set = data['rw_set']
    last_index = 0
    update_index = 0

    if len(rw_set) > 1:
        # this is a multiple-set firmware.
        print " - checking last-used firmware"
        assert data['get_last_index']
        last_index = execute_script_command(data['get_last_index'])
        if last_index < 0 or last_index >= len(rw_set):
            error_die("Cannot find proper index. Abort.")
        update_index = (last_index + 1) % len(rw_set)
        print " - select #%d firmware as update target" % update_index

    print " - checking RW data"
    rw_list = rw_set[update_index].split(',')
    update_list = []
    update_image = current_image  # prevent unexpected write

    for rw in rw_list:
        rw = rw.strip()
        if not rw:
            error_die("(INTERNAL) Invalid update list: %s" %
                      rw_set[update_index])
        current_data = flashrom.get_section(current_image, layout, rw)
        expected_data = flashrom.get_section(new_image, layout, rw)
        if current_data != expected_data:
            update_list.append(rw)
            update_image = flashrom.put_section(update_image, layout, rw,
                                                expected_data)
    if update_list:
        print " - updating firmware sections:", ','.join(update_list)
        if not flashrom.write_partial(update_image, layout, update_list):
            error_die("Cannot re-write Flash ROM. Abort.")
        print " - verifying updated firmware"
        verify_data = flashrom.read_whole()
        verify_data = apply_skip_verify(data['skip_verify'], layout, flashrom,
                                        verify_data, update_image)
        if verify_data != update_image:
            error_die("Tool return success but actual data is incorrect.")
    else:
        print " - no need to update."
        # NOTE even if no need to update, we may still need to change
        # next boot to the other firmware, so we can't return now.

    if update_index != last_index:
        print " - selecting updated firmware for next boot"
        cmd = data['select_cmd'][update_index]
        if not execute_script_command(cmd):
            error_die("Cannot set next boot firmware to #%d" % update_index)
    print " - success and complete."


def main():
    """ main stub """
    # If there is a custom script, load it now.
    custom_script = DEFAULT_CUSTOM_SCRIPT_FILENAME
    if os.path.exists(custom_script):
        # to prevent writing 'global var' in the custom script,
        # we pass globals() as both locals and globals to execfile
        execfile(custom_script, globals())

    # initialize flashrom utility
    flashrom = flashrom_util.flashrom_util(
        tool_path=DEFAULT_FLASHROM_TOOLPATH,
        cmd_prefix=DEFAULT_FLASHROM_CMDPREFIX,
        target_map=DEFAULT_FLASHROM_TARGET_MAP,
        verbose=is_verbose)

    # update all firmware targets
    for (target, data) in DEFAULT_TARGETS.items():
        update_taget_firmware(target, data, flashrom)
    print " * Firmware Update Complete."


if __name__ == '__main__':
    main()
