#!/usr/bin/env python
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Test utility for verifying ChromeOS firmware."""

import datetime
import getopt
import os
import re
import shutil
import subprocess
import sys
import tempfile
import traceback

import flashrom_handler
import flashrom_util

# Source of ACPI information.
ACPI_DIR = '/sys/bus/platform/devices/chromeos_acpi'

# This is the name of the upstart script generated by this utility. The script
# ensures that the test continues after every reboot until failed or done.
UPSTART_SCRIPT = '/etc/init/fw_test.conf'

# This is a template used to populate the upstart script described above.
upstart_script_template = '''
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Do not edit, this file was autogenerated.

# Wating on udev guarantees the file system hosted on the USB flash drive to
# be available by the time this script runs.
start on started udev

script
  exec > /tmp/fw_test.out.txt 2>&1
  dev=%s
  mkdir /tmp/"${dev}"
  mount /dev/"${dev}" /tmp/"${dev}"
  cd /tmp/"${dev}"%s
  PYTHONPATH=$(realpath ../../..) ./%s --next_step
end script

console output

'''

# Subdirectory to keep the state of this test over reboots. Created in the
# /var on the USB flash drive the test is running from.
STATE_SUBDIR = '.fw_test'

# Files storing SAFT state over reboots, located in state_dir defined below.
LOG_FILE = 'fw_test_log.txt'  # Test log.
STEP_FILE = 'fw_test_state'  # Test the step number.
FW_BACKUP_FILE = 'flashrom.bak'  # Preserved original flashrom contents.
FW_COPY_FILE = 'flashrom.new'  # A copy of the flashrom contents being tested.
FWID_BACKUP_FILE = 'fwid.bak'  # FWID reported by the original firmware.
FWID_NEW_FILE = 'fwid.new'  # FWID reported by the firmware being tested.

# The list of shell executables necessary for this program to work.
required_programs = 'vbutil_firmware reboot_mode rootdev blkid flashrom'

# Full path to the state subdirectory (depends on the USB flash drive's mount
# point, is determined at run time).
state_dir = None

FlashromHandler = flashrom_handler.FlashromHandler()

progname = ''

class FwError(Exception):
  pass


def target_hosted():
  '''Return True if running on a ChromeOS target.'''
  return 'chromeos' in open('/proc/version_signature', 'r').read()


def log(text):
  '''Print message on the screen and save it in the log file.

  The output is seen on the screen only before the first reboot. Then, after
  each reboot when this script is driven from an upstart .conf file, the output
  is dumped into /tmp/fw_test.out.txt. In case the test fails,
  /tmp/fw_test.out.txt file needs to be consulted to determine what exactly
  happened after the last reboot before the failure.

  The entire log (maintained across all reboots) can be found in
  /var/{STATE_SUBDIR}/{LOG_FILE} on the USB flash drive.
  '''

  # Don't print on the screen if this is not running as the main program
  if __name__ == '__main__':
    print text
  if not state_dir:
    return

  timestamp = datetime.datetime.strftime(
      datetime.datetime.now(), '%I:%M:%S %p:')

  log_file = os.path.join(state_dir, LOG_FILE)
  f = open(log_file, 'a')
  f.write('%s %s\n' % (timestamp, text))
  f.close()


def set_try_fw_b():
  log('Requesting restart with FW B')
  run_shell_command('reboot_mode --try_firmware_b=1')


def restore_firmware():
  log('Restoring to original firmware')
  run_shell_command('flashrom -w %s' % os.path.join(state_dir, FW_BACKUP_FILE))


def verify_fw_id(compare_to_file):
  old_fwid = open(os.path.join(state_dir, compare_to_file), 'r').read()
  now_fwid = open(os.path.join(ACPI_DIR, 'FWID'), 'r').read()
  return old_fwid == now_fwid


def corrupt_firmware(section):
  FlashromHandler.corrupt_firmware(section)

# This is a tuple of tuples controlling the SAFT state machine. The states are
# expected to be passed strictly in order. The states are identified by the
# contents of BINF.[012] files in the sys fs ACPI directory. The BINF files
# store information about the reason for reboot, what firmware/kernel
# partitions were used, etc.
#
# The first element of each component tuple is the expected state of the
# machine (a ':' concatenation of the BINF files' contents).
#
# The second element of the component tuples is the action to take to advance
# the test. The action is a function to call. The last line has action set to
# None, which indicates to the state machine that the test is over.
#
# The third component, if present, is the parameter to pass to the action
# function.

test_state_sequence = (
    ('1:1:0', set_try_fw_b),
    ('1:2:0', lambda: None),
    ('1:1:0', corrupt_firmware, 'a'),
    ('1:2:0', restore_firmware),
    ('1:1:0', None)
)


def get_step():
  step_file = os.path.join(state_dir, STEP_FILE)
  step = open(step_file, 'r').read().strip()
  return int(step)


def set_step(step):
  step_file = os.path.join(state_dir, STEP_FILE)
  open(step_file, 'w').write('%d' % step)


def exec_exists(program):
  '''Check if the passed in string is a valid executable found in PATH.'''
  for path in os.environ['PATH'].split(os.pathsep):
    exe_file = os.path.join(path, program)
    if (os.path.isfile(exe_file) or os.path.islink(exe_file)
        ) and os.access(exe_file, os.X_OK):
      return True
  return False

# The string below serves two purposes:
#
# - spell out the usage string for this program
#
# - provide text for parsing to derive command line flags. The text is split
#   to words, then the words which have -- in them are stripped off the
#   leading/traling brackets and dashes and used to prepare inut parameters
#   for getopt. This is the only way to pass the parameters to getopt, this
#   enforces that each accepted parameter is mentioned in the usage() output.
usage_string = '''
 [--image_file=<firmware_image_file>] [--pub_key=<file>] [--next_step]

  The program can be invoked in two modes.

  When invoked for the first time, most of the parameters are required to set
  up the test context and start it.

  Specifying --next_step means that the program is being invoked by the
  restarted system, all the context is expected to be available. No other
  parameters are required or expected in that case.
'''


def usage(msg='', rv=0):
  if rv:
    of = sys.stderr
  else:
    of = sys.stdout
  if msg:
    print >> of, '%s: %s' % (progname, msg)
    log(msg)
  print >> of, 'usage: %s %s' % (progname, usage_string.strip())
  sys.exit(rv)


def run_shell_command(cmd):
  '''Run a bash command.

  In case of the command returning an error print its stdout and stderr
  outputs on the console and dump them into the log. Otherwise suppress all
  output.

  In case of command error raise an FwError exception.

  Return the subprocess.Popen() instance to provide access to console output in
  case command succeeded.
  '''
  log('Executing %s' % cmd)
  p = subprocess.Popen(cmd, shell=True,
                       stdout=subprocess.PIPE,
                       stderr=subprocess.PIPE)
  p.wait()
  if p.returncode:
    err = ['Failed running: %s' % cmd]
    err.append('stdout:')
    err.append(p.stdout.read())
    err.append('stderr:')
    err.append(p.stderr.read())
    text = '\n'.join(err)
    print text
    log(text)
    raise FwError('command %s failed' % cmd)
  return p


def run_shell_command_get_output(cmd):
  '''Run bash command and return its console output to the caller.

  The output is returned as a list of strings stripped of the newline
  characters.'''
  p = run_shell_command(cmd)
  return [x.rstrip() for x in p.stdout.readlines()]


def boot_state_vector():
  '''Read and return to caller a ':' concatenated contents of BINF files.'''
  binf_fname_template = 'BINF.%d'
  state = []
  for index in range(3):
    fname = os.path.join(ACPI_DIR, binf_fname_template % index)
    state.append(open(fname, 'r').read())
  state_str = ':'.join(state)
  return state_str


def get_options_set():
  '''Generate the list of command line options accepted by this program.

  This function derives the set of accepted command line options from
  usage_string. The string is split into words, all words starting with -- are
  considered accepted command line parameters. The presence of an '=' sign in
  the word,means that the command line parameter requires a value.

  Returns a list of strings suitable for use by the getopt module.
  '''

  drop_tail = re.compile('=.*$')
  option_set = []
  items = (' '.join(usage_string.split('\n'))).split(' ')
  for item in items:
    if '--' in item:
      if item.startswith("'"):
        continue
      option = drop_tail.sub('=', item.strip('-[]'))
      if option not in option_set:
        option_set.append(option)
  return option_set


def get_writeable_mount_point(dev, tmp_dir):
  '''Return the muntpoint of the passed in device mounted in read/write more.

  If the device is already mounted and is writeable - return its mount point.
  If the device is mounted but read-only - remount it read/write and return
  its mount point. If the device is not mounted - mount it read write on the
  passsed in path and return this path.
  '''

  # The device root file system is mounted on is represented as /dev/root
  # otherwise.
  options_filter = re.compile('.*\((.+)\).*')
  root_dev = run_shell_command_get_output('rootdev')[0]
  if dev == root_dev:
    dev = '/dev/root'

  for line in run_shell_command_get_output('mount'):
    if not line.startswith(dev):
      continue
    mount_options = options_filter.match(line).groups(0)[0]
    # found mounted
    if 'ro' in mount_options.split(','):
      # mounted read only
      run_shell_command('mount -o remount,rw %s' % dev)
    return line.split()[2]  # Mountpoint is the third element of the output
  # Not found, needs to be mounted
  run_shell_command('mount %s %s' % (dev, tmp_dir))
  return tmp_dir


def handle_upstart_script(base_partition, install):
  '''Install or remove the SAFT upstart script.

  When the test prepares to start, this function is invoked to install the
  upstart script ensuring that each time the machine resets, it executes this
  program passing it the --next_step as a parameter.

  The script needs to be installed in three places: userland A, userland B
  and the recovery userland (on the USB flash drive).

  When the test finishes, it invokes this function to remove the upstart
  scripts from all three locations.
  '''

  if not target_hosted():
    print 'bypassing upstart management'
    return

  label_pattern = re.compile('/dev/(.+): LABEL="(H-ROOT-|C-KEYFOB)')
  prog_real_path = os.path.realpath(sys.argv[0])
  mydir = os.path.dirname(prog_real_path)
  tmp_dir = tempfile.mkdtemp()

  # Find out our file name off the root of the device
  mount_point = (run_shell_command_get_output('df %s' % mydir)[-1]).split()[-1]
  this_prog = prog_real_path[len(mount_point):]

  for line in run_shell_command_get_output('blkid'):
    m = label_pattern.search(line)
    if not m:
      continue
    dev = m.groups(0)[0]
    mount_point = get_writeable_mount_point('/dev/' + dev, tmp_dir)
    file_name = mount_point + UPSTART_SCRIPT
    log('Handling ' + file_name)
    if install:
      us = open(file_name, 'w')
      us.write(upstart_script_template % (
          base_partition.split('/')[-1], os.path.dirname(this_prog),
          os.path.basename(this_prog)))
      us.close()
    else:
      os.unlink(file_name)
    if mount_point.startswith(tmp_dir):
      run_shell_command('umount %s' % (tmp_dir))

  os.rmdir(tmp_dir)


def init_fw_test(opt_dictionary, base_partition, mydir, acpi_dir=ACPI_DIR):
  """Prepare firmware test context.

  This function tries creating the state directory for the fw test and
  initializes the test state machine.

  Return
    True on success
    False on any failure or if the directory already exists
  """

  if not os.path.exists(acpi_dir):
    raise FwError('ACPI directory %s not found' % acpi_dir)

  if os.path.exists(state_dir):
    raise FwError('state directory %s exists' % state_dir)
  try:
    os.mkdir(state_dir)
    log('Automated firmware test log generated on %s' %(
        datetime.datetime.strftime(datetime.datetime.now(), '%b %d %Y')))
    log('Original boot state %s' % boot_state_vector())

    # add more header data here
  except OSError, e:
    raise FwError(e)

  fw_image = opt_dictionary['image_file']
  FlashromHandler.new_image()
  FlashromHandler.verify_image()
  FlashromHandler.dump_whole(os.path.join(state_dir, FW_BACKUP_FILE))
  FlashromHandler.new_image(fw_image)
  FlashromHandler.verify_image()
  handle_upstart_script(base_partition, True)
  shutil.copyfile(os.path.join(ACPI_DIR, 'FWID'),
                  os.path.join(state_dir, FWID_BACKUP_FILE))
  shutil.copyfile(fw_image, os.path.join(state_dir, FW_COPY_FILE))
  set_step(0)


def next_step(base_partition):
  '''Function to execute a single SAFT step.

  This function is running after each reboot. It determines the current step
  the SAFT is on, executes the appropriate action, increments the step value
  and then restats the machine.
  '''

  this_step = get_step()
  FlashromHandler.new_image(os.path.join(state_dir, FW_COPY_FILE))

  if this_step == 0:
    shutil.copyfile(os.path.join(ACPI_DIR, 'FWID'),
                    os.path.join(state_dir, FWID_NEW_FILE))

    if verify_fw_id(FWID_BACKUP_FILE):
      # we expected FWID to change, but it did not - have the firmware been
      # even replaced?
      log('New firmware - old FWID')
      sys.exit(1)
  test_state_tuple = test_state_sequence[this_step]
  expected_vector = test_state_tuple[0]
  action = test_state_tuple[1]
  boot_vector = boot_state_vector()
  log('Rebooted into state %s on step %d' % (boot_vector, this_step))
  if action and not verify_fw_id(FWID_NEW_FILE):
    log('Error: Wrong FWID value')
    sys.exit(1)

  if boot_vector != expected_vector:
    log('Error: Wrong boot vector, %s was expected' % expected_vector)
    sys.exit(1)
  if not action:
    if not verify_fw_id(FWID_BACKUP_FILE):
      log('Error: Failed to restore to original firmware')
      sys.exit(1)
    log('Removing upstart scripts')
    handle_upstart_script(base_partition, False)
    log('we are done!')
    sys.exit(0)
  if len(test_state_tuple) > 2:
    log('calling %s with parameter %s' % (
        str(action), str(test_state_tuple[2])))
    action(test_state_tuple[2])
  else:
    log('calling %s' % str(action))
    action()
  set_step(this_step + 1)
  run_shell_command('reboot')


def check_runtime_env(mydir):
  """Ensure that the script is running in proper environment.

  This involves checking that the script is running off a removable device,
  configuring proper file names for logging, etc.
  """
  # Drop trailing digit(s) and letter(s) (if any)
  dev_name_stripper = re.compile('[0-9].*$')

  line = run_shell_command_get_output('df %s' % mydir)[-1]

  base_partition = line.split()[0]
  if base_partition == '/dev/root':
    base_partition = run_shell_command_get_output('rootdev')[0]

  base_dev = dev_name_stripper.sub('', base_partition.split('/')[2])
  removable = int(open('/sys/block/%s/removable' % base_dev, 'r').read())

  if not removable:
    raise FwError(
        'This test must run off a removable device, not /dev/%s' % base_dev)

  env_root = '/var'
  state_fs = '/dev/%s1' % base_dev

  # is state file system mounted?
  for line in run_shell_command_get_output('mount'):
    if line.startswith('%s on %s' % (state_fs, env_root)):
      state_root = env_root
      break
  else:
    tmp_dir = tempfile.mkdtemp()
    run_shell_command('mount %s %s' % (state_fs, tmp_dir))
    state_root = '%s%s' % (tmp_dir, env_root)

  global state_dir
  state_dir = os.path.join(state_root, STATE_SUBDIR)

  return base_partition


def main(args):
  # Process command line options
  opts, params = getopt.gnu_getopt(args, '', get_options_set())
  if (params):
    raise FwError('unrecognized parameters: %s' % ' '.join(params))

  opt_dictionary = {}
  for name, value in opts:
    opt_dictionary[name.lstrip('-')] = value

  mydir = os.path.dirname(os.path.realpath(progname))
  base_partition = check_runtime_env(mydir)

  FlashromHandler.init(client.common_lib.flashrom_util,
                        state_dir, opt_dictionary.get('pub_key'))

  if 'next_step' in opt_dictionary:
    if len(opt_dictionary) != 1:
      usage('--next_step (when specified) must be the only parameter', 1)
    next_step(base_partition)
    sys.exit(0)

  # check if all executables are available
  missing_execs = []
  for p in required_programs.split(' '):
    if not exec_exists(p):
      missing_execs.append(p)
  if missing_execs:
    usage('Program(s) %s not found in PATH' % (' '.join(missing_execs)), 1)

  for req_param in 'image_file pub_key'.split(' '):
    if req_param not in opt_dictionary:
      usage(rv=1)

  init_fw_test(opt_dictionary, base_partition, mydir)
  log('program the new image')
  FlashromHandler.write_whole()
  log('restart')
  run_shell_command('reboot')
  return 0


if __name__ == '__main__':
  progname = os.path.basename(sys.argv[0])
  try:
    main(sys.argv[1:])

  except (getopt.GetoptError, ImportError):
    usage(sys.exc_info()[1], 1)

  except (FwError, flashrom_handler.FlashromHandlerError):
    msg = 'Error: %s' % str(sys.exc_info()[1])
    print msg
    log(msg)
    sys.exit(1)

  sys.exit(0)
