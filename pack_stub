#!/bin/sh
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Version information. Please keep this in head of the updater.
TARGET_FWID="REPLACE_FWID"
TARGET_ECID="REPLACE_ECID"
TARGET_PLATFORM="REPLACE_PLATFORM"
TARGET_UNSTABLE="REPLACE_UNSTABLE"
TARGET_SCRIPT="REPLACE_SCRIPT"

# Export all version information
export TARGET_FWID TARGET_ECID TARGET_PLATFORM TARGET_UNSTABLE TARGET_SCRIPT

# All scripts should die on error unless commands are specifically excepted
# by prefixing with '!' or surrounded by 'set +e' / 'set -e'.
set -e
# Clean up on regular or error exits.
trap clean_temp EXIT

# Global variables
ORIGINAL_PARAMS="$@"

# Set by make_temp function and removed by clean_temp
TMP_DIR=
# Set by allow_temp_exec and will invoke unmount in clean_temp
IS_NEED_UMOUNT=
# Decides if we need to print verbose messages
IS_VERBOSE=
# The default script to be invoked from extracted resource
SCRIPT="./${TARGET_SCRIPT:-updater.sh}"

IGNORE_TAG_FILE='/root/.leave_firmware_alone'
force_flag=""


# Prints a message and return an error code.
error_exit() {
  echo $1
  exit 1
}

# Prints messages if $IS_VERBOSE is not empty.
verbose_message() {
  if [ -n "$IS_VERBOSE" ]; then
    echo "$*"
  fi
}

# Untar the file to a temp directory, then chdir to that directory.
untar_and_chdir() {
  SELF="$1"

  verbose_message "Extract to $TMP_DIR ..."
  uudecode -o - "$SELF" | tar -C "$TMP_DIR" -zxf -

  if [ ! -x "$TMP_DIR" -o ! -d "$TMP_DIR" ]; then
    error_exit "Create temp directory $TMP_DIR failed ..."
  fi

  if ! cd "$TMP_DIR"; then
    error_exit "Cannot chdir to $TMP_DIR ..."
  fi
}

make_temp() {
  TMP_DIR=$(mktemp -d)
}

allow_temp_exec() {
  if [ -z "$TMP_DIR" ]; then
    error_exit "allow_temp_exec: Temp folder is empty."
  fi
  # TODO(hungte) check if we really need to re-mount tmp.
  verbose_message "Bind mounting tmp path exec ..."
  mount --bind "$TMP_DIR" "$TMP_DIR"
  mount -o remount,exec "$TMP_DIR"
  IS_NEED_UMOUNT=1
}

clean_temp() {
  verbose_message "clean_temp is invoked."
  if [ -z "$TMP_DIR" ]; then
    return
  fi
  # Attempt to cd to OLDPWD
  if ! cd - >/dev/null 2>&1; then
    verbose_message "Failed to cd -. chdir'd to /"
    cd /
  fi
  if [ -n "$IS_NEED_UMOUNT" ]; then
    verbose_message "Unmount temporary folder $TMP_DIR..."
    umount "$TMP_DIR"
  fi
  verbose_message "Clean up $TMP_DIR ..."
  rm -rf "$TMP_DIR"
  TMP_DIR=""
}

SELF="$0"
RC=0
IGNORE_RC=

case "$1" in
  -V)
    # Quick way to provide version information
    uudecode -o - "$SELF" | tar zxO ./VERSION
    exit 0
    ;;
  --sb_check)
    make_temp
    untar_and_chdir "$SELF"
    md5sum -c VERSION || RC=$?
    exit $RC
    ;;
  --sb_extract)
    make_temp
    echo "The resources are extracted into: $TMP_DIR"
    untar_and_chdir "$SELF"
    # Don't remove the temporary folder on exit.
    TMP_DIR=""
    exit 0
    ;;
  -h | "-?" | --help)
    echo "
USAGE: $SELF [bundle_option|--] [updater_options]

bundle_option (only one option can be selected):
  -h,--help:  Show usage help
  -V:  show version and content of bundle
  --force:  force execution and ignore $IGNORE_TAG_FILE
  --sb_check:  check bundle ingegrity
  --sb_extract:  extract bundle content to a temporary folder

updater_options:
    "
    # Invoke updater with -h for usage help
    set -- "-h"
    force_flag=1
    IGNORE_RC=1
    ;;
  --force)
    # Pass this into updaters
    force_flag=1
    ;;
  --debug | --verbose | -v)
    # do not shift here because this needs to be passed into the script
    IS_VERBOSE=1
    ;;
  --)
    shift
    ;;
esac

# Do nothing if we're debugging BIOS changes, unless forced
if [ -e "$IGNORE_TAG_FILE" ] && [ -z "${force_flag:-}" ]; then
  echo "WARNING: $0 is disabled by $IGNORE_TAG_FILE"
  echo "To force execution, please prefix --force to your command:"
  echo " sudo $0 --force $ORIGINAL_PARAMS"
  exit 0
fi

# Prepare execution environment
make_temp
allow_temp_exec
untar_and_chdir "$SELF"
if [ ! -x $SCRIPT ]; then
  error_exit "Cannot execute $SCRIPT"
fi

# Are we running in legacy mode or new flavor?
PATH=".:$PATH"

verbose_message "Run built-in script ($SCRIPT) ..."
$SCRIPT "$@" || RC="$?"
if [ "$RC" -ne 0 -a -z "$IGNORE_RC" ]; then
  echo "ERROR: $SCRIPT failed."
fi
exit $RC

# Below are uuencoded blob. Don't put code behind exit 0.
